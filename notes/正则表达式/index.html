<!DOCTYPE html>
<html lang="zh">
  <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-2C6GZ60BVJ"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-2C6GZ60BVJ');
      </script>

      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>regex 正则表达式</title>

      <!-- Include Prism.js theme CSS -->
      <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-coy.min.css" rel="stylesheet" />
      <link rel="stylesheet" href="/assets/css/home-styles.css">
      <link rel="stylesheet" href="/assets/css/styles.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true
          }
        };
      </script>
  </head>
  <body>
    <div class="container">
      <!-- Sidebar -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <img src="/assets/images/avatar.jpg" alt="Profile Photo" class="profile-picture">
          <h3 class="sidebar-title"></h3>
        </div>
        <nav class="sidebar-nav">
          <ul>
            <li><a href="/">首页</a></li>
            <li><a href="/aboutme">关于我</a></li>
            <li class="has-submenu">
              <a href="#" class="submenu-toggle" id="notes-toggle">笔记 <span class="toggle-icon">▶</span></a>
              <ul class="submenu" id="notes-submenu"><li><a href="/notes/solidity-smart-contract/">一个简单的以太坊智能合约开发练习</a></li><li><a href="/notes/201805-osaka-kyoto/">2018年五一假期日本大阪京都奈良6日游</a></li><li><a href="/notes/面试刷题/">面试刷题</a></li><li><a href="/notes/数学笔记/">数学笔记</a></li><li><a href="/notes/日语学习/">日语学习</a></li><li><a href="/notes/正则表达式/">regex 正则表达式</a></li></ul>
            </li>
          </ul>
        </nav>
        <div class="sidebar-footer">
          <a href="https://github.com/alant" class="icon github"><i class="fab fa-github"></i></a>
          <a href="https://linkedin.com/in/alantang" class="icon linkedin"><i class="fab fa-linkedin"></i></a>
        </div>
      </aside>
      <div class="overlay" id="overlay"></div>

      <!-- Content Area -->
      <main class="content">
        <header>
          <button class="hamburger" id="hamburger">&#9776;</button>
          <h1>regex 正则表达式</h1>
        </header>
        <section>
          <h1 id="%E5%AE%9E%E9%99%85%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84" tabindex="-1">实际中遇到过的</h1>
<pre class="language-regex"><code class="language-regex"><span class="token group punctuation">(?&lt;!</span><span class="token special-escape escape">\.</span><span class="token group punctuation">)</span><span class="token anchor function">\b</span><span class="token char-set class-name">\w</span><span class="token quantifier number">+</span><span class="token group punctuation">(</span>Date<span class="token group punctuation">)</span><span class="token group punctuation">(?=</span><span class="token char-class"><span class="token char-class-punctuation punctuation">[</span>;(<span class="token char-class-punctuation punctuation">]</span></span><span class="token group punctuation">)</span></code></pre>
<p>匹配：&quot;Date&quot; 在这些字符串里 &quot;somewords someDate;&quot;, &quot; someDate;&quot; &quot;someDate(&quot;, &quot;someDate;&quot;<br>
不匹配： &quot; Date(&quot;, &quot; Date;&quot;, &quot;Date;&quot;, &quot; Date&quot;, &quot;someDate&quot;, &quot;Java.localDate;&quot;<br>
解释：</p>
<ul>
<li><code>(?&lt;!\.)</code>: 负向后行断言（negative lookbehind assertion），确保匹配的字符串前面不是一个句点（.）</li>
<li>(Date): 捕获组, 匹配字符串 Date 并将其捕获为一个组</li>
<li><code>(?=[;(])</code>: 前瞻断言 (lookahead)，表示 &quot;Date&quot; 之后必须紧跟一个分号 &quot;;&quot; 或左括号 &quot;(&quot;</li>
</ul>
<p>我之前一直搞不定如何满足不匹配 &quot;Java.localDate;&quot; 这个字符串里的 &quot;Date&quot;，<a href="https://stackoverflow.com/questions/78687342/how-to-not-match-negative-match-certain-patterns-in-lookbehind">我在stackoverflow上发了篇帖子问这个问题。很快得到了高手的帮助，给出了以上的答案</a></p>
<h1 id="%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" tabindex="-1">常用正则表达式</h1>
<h2 id="%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%BC%8F" tabindex="-1">基础模式</h2>
<h3 id="'.'-%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%82%E5%8C%B9%E9%85%8D%E9%99%A4%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%A4%96%E7%9A%84%E4%BB%BB%E4%BD%95%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6" tabindex="-1">'.' 通配符。匹配除换行符外的任何单个字符</h3>
<pre class="language-regex"><code class="language-regex">c<span class="token char-set class-name">.</span>t</code></pre>
<p>匹配: cat, cot, cut, c3t<br>
不匹配: ct, caat</p>
<p>解释：在这个例子中，它匹配 'c' 和 't' 之间的任何一个字符。但不匹配 &quot;ct&quot;（因为中间没有字符）或 &quot;cast&quot;（因为有两个字符）。</p>
<h3 id="'*'-%E9%9B%B6%E6%88%96%E5%A4%9A%E6%AC%A1%E3%80%82'*'-%E5%89%8D%E9%9D%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%AF%E4%BB%A5%E5%87%BA%E7%8E%B0%E9%9B%B6%E6%AC%A1%E6%88%96%E5%A4%9A%E6%AC%A1" tabindex="-1">'*' 零或多次。'*' 前面的字符可以出现零次或多次</h3>
<pre class="language-regex"><code class="language-regex">ca<span class="token quantifier number">*</span>t</code></pre>
<p>匹配: ct, cat, caat, caaat<br>
不匹配:: cot, cut, c3t</p>
<p>解释：'*' 前面的字符 'a' 可以出现零次或多次。它不匹配 &quot;cot&quot; 或 &quot;c3t&quot;，因为 'c' 和 't' 中间的字符不是 'a'。</p>
<h3 id="'.'-%E5%92%8C-'*'-%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8" tabindex="-1">'.' 和 '*' 组合使用</h3>
<pre class="language-regex"><code class="language-regex">c<span class="token char-set class-name">.</span><span class="token quantifier number">*</span>t</code></pre>
<p>匹配: ct, cat, cot, cut, c@t, c t, caaat<br>
不匹配: ca, at, tc</p>
<p>解释：'.*' 组合可以匹配任意数量的任意字符。在这个例子中，模式要求字符串以 'c' 开始，以 't' 结束，中间可以是任何内容（包括没有内容）。</p>
<h3 id="'%3F'-%E9%9B%B6%E6%AC%A1%E6%88%96%E4%B8%80%E6%AC%A1%E3%80%82'%3F'-%E5%89%8D%E9%9D%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%AF%E4%BB%A5%E5%87%BA%E7%8E%B0%E9%9B%B6%E6%AC%A1%E6%88%96%E4%B8%80%E6%AC%A1" tabindex="-1">'?' 零次或一次。'?' 前面的字符可以出现零次或一次</h3>
<pre class="language-regex"><code class="language-regex">ca<span class="token quantifier number">?</span>t</code></pre>
<p>匹配: ct, cat<br>
不匹配: caat, cot, cut, c3t</p>
<h3 id="'%2B'-%E4%B8%80%E6%AC%A1%E6%88%96%E5%A4%9A%E6%AC%A1%2C-'%2B'-%E5%89%8D%E9%9D%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E5%BF%85%E9%A1%BB%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%88%96%E5%A4%9A%E6%AC%A1" tabindex="-1">'+' 一次或多次, '+' 前面的字符必须出现一次或多次</h3>
<pre class="language-regex"><code class="language-regex">ca<span class="token quantifier number">+</span>t</code></pre>
<p>匹配: cat, caat, caaat<br>
不匹配: ct, cot, cut</p>
<p>解释：<br>
在这个例子中，'a' 必须至少出现一次。这就是为什么它匹配 &quot;cat&quot;（一个 'a'）、&quot;caat&quot;（两个 'a'）和 &quot;caaat&quot;（三个 'a'）。但它不匹配 &quot;ct&quot;（没有 'a'）、&quot;cot&quot; 或 &quot;cut&quot;（因为中间的字符不是 'a'）。</p>
<h3 id="'%5Cw'-%E5%8D%95%E8%AF%8D%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%AD%97%E6%AF%8D%E3%80%81%E6%95%B0%E5%AD%97%E5%92%8C%E4%B8%8B%E5%88%92%E7%BA%BF" tabindex="-1">'\w' 单词字符，包括字母、数字和下划线</h3>
<pre class="language-regex"><code class="language-regex">c<span class="token char-set class-name">\w</span>t</code></pre>
<p>匹配: cat, cot, cut<br>
不匹配: ct, c@t, c t</p>
<p>解释：在这个例子中：不匹配 &quot;ct&quot;，因为缺少中间的字符。不匹配 &quot;c@t&quot; 或 &quot;c t&quot;，因为 @ 和空格不是单词字符。</p>
<h3 id="'%5Cd'-%E6%95%B0%E5%AD%97" tabindex="-1">'\d' 数字</h3>
<pre class="language-regex"><code class="language-regex">c<span class="token char-set class-name">\d</span>t</code></pre>
<p>匹配: c1t, c2t, c3t<br>
不匹配: cat, cot, cut</p>
<h3 id="'%5E'-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A7%8B" tabindex="-1">'^' 字符串始</h3>
<pre class="language-regex"><code class="language-regex"><span class="token anchor function">^</span>cat</code></pre>
<p>匹配: cat in &quot;cat is cute&quot;<br>
不匹配: cat in &quot;the cat is cute&quot;</p>
<h3 id="'%24'-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%BE" tabindex="-1">'$' 字符串尾</h3>
<pre class="language-regex"><code class="language-regex">cat<span class="token anchor function">$</span></code></pre>
<p>匹配: cat in &quot;look at the cat&quot;<br>
不匹配: cat in &quot;cat is cute&quot;</p>
<h3 id="'()'-%E6%8D%95%E8%8E%B7%E7%BB%84" tabindex="-1">'()' 捕获组</h3>
<pre class="language-regex"><code class="language-regex"><span class="token group punctuation">(</span>ca<span class="token group punctuation">)</span><span class="token quantifier number">+</span>t</code></pre>
<p>匹配: cat, cacat, cacacat<br>
不匹配: ct, cot, cut<br>
解释：(ca)+ 匹配一个或多个 &quot;ca&quot; 重复，后面跟着 &quot;t&quot;。</p>
<h3 id="'%7Bn%7D'-%E7%B2%BE%E7%A1%AE%E9%87%8D%E5%A4%8D%2C-%E5%89%8D%E9%9D%A2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%BF%85%E9%A1%BB%E7%B2%BE%E7%A1%AE%E9%87%8D%E5%A4%8Dn%E6%AC%A1" tabindex="-1">'{n}' 精确重复, 前面的模式必须精确重复n次</h3>
<pre class="language-regex"><code class="language-regex"><span class="token group punctuation">(</span>c<span class="token char-set class-name">.</span>t<span class="token group punctuation">)</span><span class="token quantifier number">{3}</span></code></pre>
<p>匹配: catcotcut, cutcatcot, cotcutcat, catcatcat, cotcotcot<br>
不匹配: catcot<br>
{n,m}' 前面的模式重复n~m次</p>
<h3 id="%E4%BA%A4%E6%9B%BF" tabindex="-1">交替</h3>
<pre class="language-regex"><code class="language-regex">cat<span class="token alternation keyword">|</span>cot<span class="token alternation keyword">|</span>cut
c<span class="token char-class"><span class="token char-class-punctuation punctuation">[</span>aou<span class="token char-class-punctuation punctuation">]</span></span>t</code></pre>
<p>匹配: cat, cot, cut<br>
不匹配: ct, caat, cooot</p>

        </section>
        <footer class="footer">
          <div class="footer-container">
            <p>© <span id="current-year"></span> 汤浩</p>
          </div>
        </footer>
      </main>

      

    </div>

    <!-- Mobile Back to Top Button -->
    <button class="back-to-top" id="back-to-top" aria-label="Back to top">▲</button>

    

    <script>
      document.getElementById('current-year').textContent = new Date().getFullYear();

      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('overlay');
      const hamburger = document.getElementById('hamburger');

      hamburger.addEventListener('click', () => {
        sidebar.classList.toggle('open');
        overlay.classList.toggle('show');
      });

      overlay.addEventListener('click', () => {
        sidebar.classList.remove('open');
        overlay.classList.remove('show');
      });

      // Submenu toggle
      const notesToggle = document.getElementById('notes-toggle');
      const notesSubmenu = document.getElementById('notes-submenu');

      notesToggle.addEventListener('click', (e) => {
        e.preventDefault();
        notesSubmenu.classList.toggle('open');
        notesToggle.classList.toggle('open');
      });

      // Back to top button
      const backToTop = document.getElementById('back-to-top');
      const contentArea = document.querySelector('.content');

      backToTop.addEventListener('click', () => {
        contentArea.scrollTo({ top: 0, behavior: 'smooth' });
      });

      // Show/hide back to top button based on scroll position
      contentArea.addEventListener('scroll', () => {
        if (contentArea.scrollTop > 300) {
          backToTop.classList.add('visible');
        } else {
          backToTop.classList.remove('visible');
        }
      });

      
    </script>
  </body>
</html>
